import{_ as l,o as i,c as e,f as p}from"./app.d5111385.js";const t="/assets/image.8ba52015.png",v=JSON.parse('{"title":"嗯哇面经验","description":"面试官是了解新技术的，面的很爽","frontmatter":{"date":"2024-03-04T00:00:00.000Z","title":"嗯哇面经验","description":"面试官是了解新技术的，面的很爽","tags":["面试"]},"headers":[],"relativePath":"posts/嗯哇科技.md"}'),u={name:"posts/嗯哇科技.md"},s=p('<ul><li><p>自我介绍</p></li><li><p>算法题</p><ul><li>实现树结构数据平铺到一个新数组 <ul><li>递归/迭代</li></ul></li><li>一个长度为10000的数组，取最小值 <ul><li>数据量的问题</li></ul></li></ul></li><li><p>实现响应式布局有哪几种方法</p><ul><li>flex+百分比</li><li>rem em 移动端</li><li>媒体查询</li></ul></li><li><p>vw vh rem em什么区别</p><ul><li>vw vh根据窗口大小变化</li><li>rem根据根元素设置的元素大小变化</li><li>em根据父元素设置的元素大小变化</li></ul></li><li><p>项目用到了unocss，说一下原子化css</p></li><li><p>乾坤框架</p><ul><li>微前端</li><li>模块化开发</li><li>共享组件</li><li>性能优化</li><li>路由管理</li></ul></li><li><p>element-ui 没有虚拟滚动，数据量大的时候你是怎么处理的</p><ul><li>分页加载</li><li>使用虚拟列表组件</li><li>虚拟滚动，只渲染当前用户可见的页面 <ul><li>计算可见区域</li><li>只渲染可见项</li><li>重用列表项： 当用户滚动时，更新可见区域内的列表项的数据，而不是创建新的DOM元素。</li><li>加载更多数据： 如果是分页加载，当用户滚动到列表底部时，加载下一页的数据并更新可见区域。</li></ul></li></ul></li><li><p>你用别人的组件，别人已经封装的组件没有你要的prop，你如何给他加上你要的属性</p><ul><li>$set</li></ul></li><li><p>组件未显式地声明prop属性是如何透传的</p><ul><li>使用$attrs接受</li></ul></li><li><p>vben的封装组件的封装和hooks的封装</p></li><li><p>vben使用起来感觉</p></li><li><p>es6语法常用的语法</p></li><li><p>你最常用的Promise类方法</p></li><li><p>vue2和vue3使用起来的差别</p></li><li><p>hooks和mixins的异同</p><ul><li>都是为了逻辑服用</li><li>hooks v3 mixins v2</li></ul></li><li><p>vue如何实现数组的响应式追踪</p><ul><li>面试官的意思是在对象的基础上数组方法没有实现响应式，比如使用push,pop,unshift,shift等方法不回触发响应式</li><li>对方法进行遍历，然后把方法添加进去</li></ul></li><li><p>微任务 宏任务</p><ul><li>微 <ul><li>Promise回调</li><li>process.nextTick</li><li>MutationObserver</li></ul></li><li>宏 <ul><li>setTimeout</li><li>setInterval</li></ul></li></ul></li><li><p>nextTick</p><ul><li>nextTick是一个用于在DOM更新队列被刷新之后执行回调的方法。</li><li><img src="'+t+'" alt="alt text"></li></ul></li><li><p>性能优化</p><ul><li>路由懒加载</li><li>组件懒加载</li><li>使用 keep-alive 缓存组件</li><li>CDN 加载 Vue 及其相关资源</li><li>图片优化</li><li>代码拆分（Code Splitting）</li><li>Tree-shaking</li><li>减少重绘和重排</li></ul></li><li><p>树摇的原理</p><ul><li>ES6 模块系统</li><li>静态分析：Tree-shaking 是通过静态分析代码来判断哪些代码是未使用的。因此，它只能处理那些在编译时就能确定的引用关系，而不考虑运行时动态生成的引用。</li><li>通过工具实现：主流的 JavaScript 打包工具，如Webpack和Rollup，提供了对 tree-shaking 的支持。在配置文件中开启相应选项，这样工具就能够在打包时识别和移除未使用的代码。</li></ul></li><li><p>二次封装过插件吗，自动引入的插件，如何配置plugin</p></li><li><p>websocket</p><ul><li>WebSocket是一种在Web浏览器和Web服务器之间建立持久性连接的通信协议。与传统的HTTP通信方式不同，WebSocket允许在客户端和服务器之间实时双向通信，而无需每次通信都建立新的连接。</li><li>客户端 <ul><li>创建WebSocket对象</li><li>定义事件处理函数</li><li>发送消息</li></ul></li></ul></li><li><p>socket</p></li><li><p>chatgpt的通信方式</p><ul><li>开发者通过 API 密钥认证身份，以访问 ChatGPT 的服务。</li><li>发送包含用户输入的文本请求到 API。</li><li>ChatGPT 处理请求，生成相应的文本输出。</li><li>开发者从 API 接收模型生成的文本响应。</li></ul></li><li><p>说下大文件流下载</p><ul><li>对文件进行切割</li><li>Blob <ul><li>发送网络请求获取要下载的内容</li><li>把内容传入Blob实例</li><li>创建下载链接</li></ul></li></ul></li><li><p>说一下你如何配置git规范</p></li></ul>',1),o=[s];function a(n,r,c,_,m,h){return i(),e("div",null,o)}const T=l(u,[["render",a]]);export{v as __pageData,T as default};
