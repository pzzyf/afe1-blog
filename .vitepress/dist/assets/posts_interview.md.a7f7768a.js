import{_ as l,o as i,c as t,f as e}from"./app.397019da.js";const s="/assets/image-2.e4c37d9a.png",a="/assets/image-3.ba48c2d6.png",r="/assets/image-4.f007ea41.png",o="/assets/image-5.6ea0bda0.png",c="/assets/image-6.797760ea.png",u="/assets/image-7.e6d4f2a3.png",m="/assets/image-8.994089f5.png",n="/assets/image-9.39b5153f.png",p="/assets/image-10.91c2f3a6.png",g="/assets/image-0.54bd622a.png",_="/assets/image-1.a79d9df6.png",d="/assets/image-11.8f906425.png",x="/assets/image-12.f80035f6.png",f="/assets/image-13.1def09d9.png",b="/assets/image-14.d36a3b2a.png",h="/assets/image-15.89b404c3.png",v="/assets/image-16.9f369093.png",y="/assets/image-17.cf1f65c3.png",S="/assets/image-18.a41837c6.png",P="/assets/image-19.2b72b979.png",w="/assets/image-20.6ae8f3cb.png",j="/assets/image-21.461374c2.png",R="/assets/image-22.4b015b6e.png",M="/assets/image-23.2da3d7b5.png",T="/assets/image-24.9f586f4a.png",E="/assets/image-25.c7d6ee59.png",O="/assets/image-26.fd89224d.png",N="/assets/image-27.8b016629.png",k="/assets/image-28.bb62992c.png",B="/assets/image-29.d27694c7.png",A="/assets/image-30.b46e7a80.png",z="/assets/image-31.60c99ae0.png",J="/assets/image-32.0756c121.png",L="/assets/image-33.ccd89d69.png",U="/assets/image-34.b1b5a67e.png",V="/assets/image-35.b1a36353.png",$="/assets/image-36.9dec2c3b.png",C="/assets/image-37.68bc1329.png",D="/assets/image-38.e0829173.png",I="/assets/image-39.bf416d3a.png",G="/assets/image-40.c8fbec02.png",q="/assets/image-41.32346809.png",F="/assets/image-42.16f6e422.png",Q="/assets/image-43.26dec398.png",Z="/assets/image-44.4bc77d99.png",H="/assets/image-45.d8f5220f.png",K="/assets/image-46.77bb9d24.png",W="/assets/image-47.7848d3e2.png",X="/assets/image-48.2c2ee50d.png",Y="/assets/image-49.f794d00c.png",ll="/assets/image-50.b707b7c7.png",pl=JSON.parse('{"title":"北京小诚互娱面经","description":"带我八股全复习了一遍真好","frontmatter":{"date":"2024-02-29T00:00:00.000Z","title":"北京小诚互娱面经","description":"带我八股全复习了一遍真好","tags":["面试"]},"headers":[],"relativePath":"posts/interview.md"}'),il={name:"posts/interview.md"},tl=e('<ul><li><p>1.自我介绍</p></li><li><p>2.html5，css3的新特性</p><ul><li>html5 <ul><li>语意化：引入语义元素 head,nav,main,footer</li><li>多媒体支撑：内置对音评和视频的支持，audio video</li><li>提供canves元素：使用js可以绘制画布</li><li>本地存储：提供了LocalStorage，SessionStorage</li></ul></li><li>css3 <ul><li>圆角（Border-radius）</li><li>阴影（Box-shadow）</li><li>渐变（Gradient）</li><li>过渡（Transition）</li><li>动画（Animation）</li><li>多栏布局（Multi-column layout）</li><li>变形（Transform）</li><li>媒体查询（Media Queries</li></ul></li></ul></li><li><p>3.flex布局常用的属性</p><ul><li>父元素的应用 <ul><li>flex-direction(方向)</li><li>flex-wrap(换行)</li><li>justify-content(主轴对其方式)</li><li>align-item(交叉轴对其方式)</li></ul></li><li>子元素上的应用 <ul><li>order（项目排列顺序）</li><li>flex-graw(项目放大比例) <ul><li><img src="'+s+'" alt="alt text"></li><li><img src="'+a+'" alt="alt text"></li><li><img src="'+r+'" alt="alt text"></li></ul></li><li>flex-shrink(项目缩小比例) <ul><li><img src="'+o+'" alt="alt text"></li><li><img src="'+c+'" alt="alt text"></li><li><img src="'+u+'" alt="alt text"></li></ul></li><li>flex-basis(在主轴上初始大小)</li><li>flex简写:flex-grow flex-shrink flex-basis</li><li>align-self(覆盖已有的 align-items 的值) <ul><li><img src="'+m+'" alt="alt text"></li><li><img src="'+n+'" alt="alt text"></li><li><img src="'+p+'" alt="alt text"></li></ul></li></ul></li></ul></li><li><p>4.如果你只有2个元素，使用flex布局justify-content: space-between,如何实现一行有三个的效果</p><ul><li><img src="'+g+'" alt="alt text"></li><li><img src="'+_+'" alt="alt text"></li></ul></li><li><p>5.盒模型：标准盒模型/怪异盒模型</p><ul><li>标准盒子模型width = content box-sizing: content-box <ul><li><img src="'+d+'" alt="alt text"></li></ul></li><li>怪异盒模型width = content + padding + border box-sizing: border-box <ul><li><img src="'+x+'" alt="alt text"></li></ul></li></ul></li><li><p>6.数据类型</p><ul><li>基础数据类型：Undefined Null String Number Boolean Symbol BigInt</li><li>引用数据类型：Object Array Function Date RegExp Map Set Promise Symbol</li><li>区别 <ul><li>基础数据类型 <ul><li>存放在栈中</li><li>直接存储变量的值</li><li>拷贝创建独立副本 <ul><li><img src="'+f+'" alt="alt text"></li></ul></li></ul></li><li>引用数据类型 <ul><li>存放在堆中</li><li>存储的是对象的引用地址</li><li>拷贝仅拷贝引用地址 <ul><li><img src="'+b+'" alt="alt text"></li></ul></li></ul></li></ul></li></ul></li><li><p>Map Set</p><ul><li>Map <ul><li>Map是一种在 JavaScript 中存储键值对的数据结构。与普通的对象不同，Map的键可以是任何数据类型，包括原始类型和对象。在使用 Map 时，键不会被强制转换为字符串。</li><li>Map入参给可迭代对象 <ul><li><img src="'+h+'" alt="alt text"></li></ul></li><li>Map把可迭代对象当成入参是创建一个新的堆内存，改变Map创建的对象属性值不会改变原对象的值</li><li>方法：get set has delete</li></ul></li></ul></li><li><p>Set</p><ul><li>Set提供了一种简单的方法来存储和查询一组值，而无需考虑重复。（是Set类型的对象）</li><li>Set把可迭代对象当成入参是创建一个新的堆内存，改变Map创建的对象属性值不会改变原对象的值</li><li>方法：add delete has clear size forEach</li></ul></li><li><p>遍历数组常用的方法</p><ul><li>for循环会改变原数组没新的返回值 <ul><li><img src="'+v+'" alt="alt text"></li><li><img src="'+y+'" alt="alt text"></li></ul></li><li>for of会改变原数组没新返回值 <ul><li><img src="'+S+'" alt="alt text"></li><li><img src="'+P+'" alt="alt text"></li></ul></li><li>forEach不会修改原数组也没有返回值 <ul><li><img src="'+w+'" alt="alt text"></li><li><img src="'+j+'" alt="alt text"></li></ul></li><li>map不会修改原数组的值并且放回一个新数组 <ul><li><img src="'+R+'" alt="alt text"></li><li><img src="'+M+'" alt="alt text"></li></ul></li><li>filter不会修改原数组的值并且放回一个数组 <ul><li><img src="'+T+'" alt="alt text"></li><li><img src="'+E+'" alt="alt text"></li></ul></li><li>reduce累加器不会修改原数组的值并且返回累加值 <ul><li><img src="'+O+'" alt="alt text"></li><li><img src="'+N+'" alt="alt text"></li></ul></li></ul></li><li><p>es6</p><ul><li><p>var let const定义变量能不能改变</p><ul><li>const定义基础数据类型不能改变，定义引用数据类型可以改变</li></ul></li><li><p>箭头函数this绑定，箭头函数是不是构造函数</p><ul><li>没有自己的this,继承上下文的this</li><li>构造函数是可以通过new关键字创建对象实例，箭头函数没有this绑定，不能作为构造函数</li></ul></li><li><p>说一下Promise</p><ul><li>Promise就是承诺的意思，制定了一套规范，提供了一种更清晰、更结构化的方式来处理异步编程 <ul><li><img src="'+k+'" alt="alt text"></li><li><img src="'+B+'" alt="alt text"></li></ul></li><li>传入的这个函数, 被称之为 executor(执行体) <ul><li>resolve: 回调函数, 在成功时, 回调resolve函数</li><li>reject: 回调函数, 在失败时, 回调reject函数</li></ul></li><li>Promise 提供两种回调函数 <ul><li>resolve 成功时回调</li><li>reject 失败时回调 <ul><li><img src="'+A+'" alt="alt text"><ul><li>then方法传入的回调函数两个回调函数</li><li>第一个回调函数, 会在Promise执行resolve函数时, 被回调</li><li>第二个回调函数, 会在Promise执行reject函数时, 被回调</li></ul></li><li><img src="'+z+'" alt="alt text"><ul><li>catch方法传入的回调函数, 会在Promise执行reject函数时, 被回调</li></ul></li></ul></li></ul></li><li>Promise的三种状态（pending待定状态，rejected拒绝状态，fulfilled敲定状态） <ul><li><img src="'+J+'" alt="alt text"></li></ul></li><li>resolve参数 （普通的值或者对象/Promise实例对象/带有then方法的对象） <ul><li><img src="'+L+'" alt="alt text"></li><li><img src="'+U+'" alt="alt text"></li><li><img src="'+V+'" alt="alt text"></li></ul></li><li>Promise对象方法（then,catch,finally）</li><li>Promise的类方法（resolve,reject,all,allSettled,race,,any） <ul><li>all(按入参顺序打印，有reject进去catch) <ul><li><img src="'+$+'" alt="alt text"></li><li><img src="'+C+'" alt="alt text"></li></ul></li><li>allSettled所有都打印，标注promise状态和返回值 <ul><li><img src="'+D+'" alt="alt text"></li><li><img src="'+I+'" alt="alt text"></li></ul></li><li>race谁最快执行谁，resolve进then，reject进catch <ul><li><img src="'+G+'" alt="alt text"></li><li><img src="'+q+'" alt="alt text"></li></ul></li><li>any 任意一个变为fullfilled就执行那个，全为rejected则reject全执行</li></ul></li></ul></li><li><p>迭代器/生成器</p><ul><li>迭代器有next方法的对象，next返回固定格式 <ul><li><img src="'+F+'" alt="alt text"></li></ul></li><li>可迭代对象 <ul><li><img src="'+Q+'" alt="alt text"></li></ul></li><li>内置可迭代对象（数组，Map/Set对象，参数arguments）使用names[Symbol.iterator]访问，调用next方法运行</li></ul></li><li><p>可迭代对象运用场景</p><ul><li>for of语法糖</li><li>展开运算符</li><li>解构</li></ul></li><li><p>生成器函数</p><ul><li>fuction* yield</li><li>可用控制函数的运行</li><li>调用生成器函数返回生成器对象</li></ul></li><li><p>async/await</p><ul><li>生成器函数的语法糖</li><li>只使用async和普通函数无区别</li><li>函数返回值为promise对象 await后面表达式 <ul><li>1.返回一个值</li><li>2.返回thenable</li><li>3.返回Promise</li></ul></li><li>awiat后为什么 <ul><li>为then里面的代码块</li><li>await没执行完后面不执行</li><li>再遇到await再等待他执行完成</li></ul></li></ul></li><li><p>Proxy/Reflect</p><ul><li>监听对象操作方法 <ul><li>Object.defineProperty只有get和set两种方法 <ul><li><img src="'+Z+'" alt="alt text"></li></ul></li><li>new Proxy有13种捕获器 <ul><li><img src="'+H+'" alt="alt text"></li></ul></li></ul></li><li>Proxy常用捕获器（get/set/has/deleteProperty） <ul><li><img src="'+K+'" alt="alt text"></li></ul></li></ul></li><li><p>Reflect</p><ul><li>取代Object</li><li>入参 <ul><li>Reflect.get(target, key, receiver)</li><li>Reflect.set(target, key, newValue, receiver)</li></ul></li><li>receiver全是就是代理对象</li></ul></li></ul></li><li><p>vue</p><ul><li>vue核心组成部分 <ul><li>Compiler模块 template -&gt; render</li><li>Reactivity模块 响应式系统 给数据添加响应式</li><li>Runtime模块 渲染系统 <ul><li>render -&gt; vnode</li><li>虚拟dom挂载到真实dom上</li><li>patch函数，对比vnode，处理新的vnode</li></ul></li></ul></li><li>说一下深拷贝和浅拷贝 <ul><li>浅拷贝仅复制对象的第一层属性，而不会复制嵌套对象的内部引用,因此嵌套对象内部的改变会影响到原始对象。 <ul><li><img src="'+W+'" alt="alt text"></li><li><img src="'+X+'" alt="alt text"></li></ul></li><li>浅拷贝的方法 <ul><li>扩展运算符</li><li>Object.assign()</li></ul></li><li>深拷贝会递归复制对象及嵌套对象，创造一个全新的数据，不会影响原对象 <ul><li>手写递归</li><li>JSON.parse + JSON.stringify(不包含函数和特殊对象的情况) <ul><li><img src="'+Y+'" alt="alt text"></li><li><img src="'+ll+'" alt="alt text"></li></ul></li></ul></li></ul></li><li>vue的响应式原理 <ul><li>数据劫持和依赖收集</li></ul></li><li>vue2和vue3响应式原理的区别 <ul><li>vue2用的是Obejct.defineProperty,vue3用的是Proxy和Reflect来监听数据变化</li></ul></li><li>computed <ul><li>动态计算实例对象数据</li><li>缓存机制（只要当依赖数据发生变化才执行</li><li>优化 <ul><li>lazy（首次访问才计算）</li><li>cache（设置为false禁止缓存</li></ul></li><li>不能和data里面的数据重名，重名会使data里面数据覆盖computed里面的计算属性</li></ul></li><li>watch <ul><li>监听数据变化并执行一些副作用</li><li>watch可以同时监听多个数据变化</li></ul></li><li>v-model原理 <ul><li>v-bind+@change</li></ul></li><li>vuex状态管理 <ul><li>state</li><li>getter</li><li>mutation</li><li>action</li><li>module</li><li>mapState mapGetters</li></ul></li><li>vue-router <ul><li>嵌套路由children</li><li>query和params</li><li>全局路由守卫，独享路由守卫，组件路由守卫 <ul><li>router.beforeEach,router.aferEach</li><li>beforeRouteEnter beforeRouteUpdate beforeRouteLeave</li><li>可以在组件里面编写独享路由守卫</li><li>三个参数to，from，next(),next最重要</li><li>路由的两种模式 <ul><li>hash <ul><li>在 URL 中使用 # 符号来表示路由</li><li>地址栏井号斜杠后面的所有参数都是hash值 特点是不随http请求发给服务器</li></ul></li><li>history <ul><li>不使用 # 符号，而是直接使用真实的 URL 路径</li><li>部署线上需要后端支持，解决刷新页面404问题</li></ul></li></ul></li></ul></li></ul></li><li>git常用的指令</li></ul></li></ul>',1),el=[tl];function sl(al,rl,ol,cl,ul,ml){return i(),t("div",null,el)}const gl=l(il,[["render",sl]]);export{pl as __pageData,gl as default};
